<!DOCTYPE html>
<html>
<head>
    <title>消消乐</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 20px 0;
        }

        #game-container {
            width: 334px;
            height: 484px;
            padding: 10px;
            border-radius: 15px;
            position: relative;
            overflow: hidden;
        }

        #grid {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 2px;
            width: 100%;
            height: calc(100% - 60px);
        }

        .tile {
            width: 40px;
            height: 40px;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8f8f8;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .tile.selected {
            transform: scale(0.9);
            box-shadow: 0 0 10px #2196F3;
            background: #e3f2fd;
        }

        .tile svg {
            width: 30px;
            height: 30px;
        }

        #controls {
            position: absolute;
            bottom: 10px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: space-between;
            padding: 0 10px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 20px;
            background: #2196F3;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.3s;
        }

        button:hover {
            background: #1976D2;
        }

        #game-info {
            width: 334px;
            margin: 15px 0;
            padding: 15px;
            background: white;
            border-radius: 12px;
            border: 1px solid #eee;
            font-family: Arial;
            font-size: 14px;
        }

        #game-info h3 {
            margin: 0 0 10px 0;
            color: #333;
        }

        #game-info ul {
            margin: 0;
            padding-left: 20px;
            color: #666;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div id="grid"></div>
        <div id="score">得分: 0</div>
    </div>

    <!-- SVG符号定义 -->
    <svg style="display: none;">
        <symbol id="cat" viewBox="0 0 32 32">
            <path fill="#FFB347" d="M16 5a10 10 0 0 0-10 10 8 8 0 0 0 2 5l-2 5h20l-2-5a8 8 0 0 0 2-5 10 10 0 0 0-10-10z"/>
            <circle cx="12" cy="14" r="2" fill="#333"/>
            <circle cx="20" cy="14" r="2" fill="#333"/>
            <path fill="none" stroke="#333" d="M12 19q4 2 8 0"/>
        </symbol>

        <symbol id="flower" viewBox="0 0 32 32">
            <circle cx="16" cy="16" r="4" fill="#FF69B4"/>
            <ellipse cx="16" cy="9" rx="4" ry="6" fill="#FF1493"/>
            <ellipse cx="23" cy="16" rx="4" ry="6" fill="#FF1493" transform="rotate(90 16 16)"/>
            <ellipse cx="16" cy="23" rx="4" ry="6" fill="#FF1493" transform="rotate(180 16 16)"/>
            <ellipse cx="9" cy="16" rx="4" ry="6" fill="#FF1493" transform="rotate(270 16 16)"/>
        </symbol>

        <symbol id="diamond" viewBox="0 0 32 32">
            <path fill="#00BFFF" d="M16 3l13 13-13 13-13-13z"/>
            <path fill="#1E90FF" d="M16 3l10 10-10 10-10-10z"/>
            <path fill="#4169E1" d="M16 3l5 5-5 5-5-5z"/>
        </symbol>

        <symbol id="leaf" viewBox="0 0 32 32">
            <path fill="#32CD32" d="M16 3c0 8-5 12-5 19 6-5 10-7 16-7-6 6-8 10-13 10 5-3 7-7 7-13-6 5-10 7-15 3z"/>
            <path stroke="#228B22" fill="none" d="M16 5v22"/>
        </symbol>

        <symbol id="star" viewBox="0 0 32 32">
            <path fill="#FFD700" d="M16 3l5 10 11 2-8 7 2 11-10-5-10 5 2-11-8-7 11-2z"/>
            <circle cx="16" cy="16" r="4" fill="#FF6347"/>
        </symbol>

        <symbol id="potion" viewBox="0 0 32 32">
            <path fill="#9370DB" d="M12 5h8v18h-8z"/>
            <path fill="#6A5ACD" d="M16 23c4 0 6 4 6 4H10s2-4 6-4z"/>
            <path fill="#FF69B4" d="M16 12a3 3 0 1 0 0-6 3 3 0 0 0 0 6z"/>
        </symbol>
    </svg>

<script>
const ROWS = 8;
const COLS = 8;
const TYPES = ['cat', 'flower', 'diamond', 'leaf', 'star', 'potion'];
let selectedTile = null;
let score = 0;

function initGrid() {
    const grid = document.getElementById('grid');
    let validGrid = false;
    let attempts = 0;

    while (!validGrid && attempts < 100) {
        grid.innerHTML = '';
        const tempTiles = [];

        // 生成临时网格数据（避免初始三连）
        for (let row = 0; row < ROWS; row++) {
            for (let col = 0; col < COLS; col++) {
                let allowedTypes = [...TYPES];

                // 检查横向可能的三连
                if (col >= 2) {
                    const left1 = tempTiles[row * COLS + (col-1)];
                    const left2 = tempTiles[row * COLS + (col-2)];
                    if (left1 === left2) {
                        allowedTypes = allowedTypes.filter(t => t !== left1);
                    }
                }

                // 检查纵向可能的三连
                if (row >= 2) {
                    const up1 = tempTiles[(row-1) * COLS + col];
                    const up2 = tempTiles[(row-2) * COLS + col];
                    if (up1 === up2) {
                        allowedTypes = allowedTypes.filter(t => t !== up1);
                    }
                }

                // 如果无可用类型则重置
                if (allowedTypes.length === 0) allowedTypes = [...TYPES];

                // 随机选择类型
                const type = allowedTypes[Math.floor(Math.random() * allowedTypes.length)];
                tempTiles.push(type);
            }
        }

        // 创建DOM元素
        tempTiles.forEach(type => {
            const tile = createTile(type);
            grid.appendChild(tile);
        });

        // 最终验证
        if (!hasMatches()) {
            validGrid = true;
        } else {
            attempts++;
            grid.innerHTML = '';
        }
    }

    if (attempts >= 100) {
        alert('无法生成有效网格，正在强制生成...');
        newGame();
    }
}

function createTile(type) {
    const tile = document.createElement('div');
    tile.className = 'tile';
    tile.dataset.type = type;

    const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    const use = document.createElementNS("http://www.w3.org/2000/svg", "use");
    use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${type}`);

    svg.appendChild(use);
    tile.appendChild(svg);
    tile.addEventListener('click', handleTileClick);
    return tile;
}

function hasMatches() {
    const tiles = Array.from(grid.children);

    // 横向检查
    for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS - 2; col++) {
            const index = row * COLS + col;
            if (tiles[index].dataset.type === tiles[index+1].dataset.type &&
                tiles[index].dataset.type === tiles[index+2].dataset.type) {
                return true;
            }
        }
    }

    // 纵向检查
    for (let col = 0; col < COLS; col++) {
        for (let row = 0; row < ROWS - 2; row++) {
            const index = row * COLS + col;
            if (tiles[index].dataset.type === tiles[index+COLS].dataset.type &&
                tiles[index].dataset.type === tiles[index+2*COLS].dataset.type) {
                return true;
            }
        }
    }

    return false;
}

function newGame() {
    score = 0;
    document.getElementById('score').textContent = '得分: 0';
    initGrid();
}

function handleTileClick(e) {
    const tile = e.target.closest('.tile');

    if (!selectedTile) {
        selectedTile = tile;
        tile.classList.add('selected');
    } else {
        if (areAdjacent(selectedTile, tile)) {
            swapTiles(selectedTile, tile);
            checkMatches();
        }
        selectedTile.classList.remove('selected');
        selectedTile = null;
    }
}

function swapTiles(tile1, tile2) {
    const tempType = tile1.dataset.type;
    tile1.dataset.type = tile2.dataset.type;
    tile2.dataset.type = tempType;

    // 添加交换动画
    tile1.style.transform = 'scale(1.1)';
    tile2.style.transform = 'scale(1.1)';
    setTimeout(() => {
        tile1.style.transform = '';
        tile2.style.transform = '';
    }, 200);

    // 更新SVG显示
    [tile1, tile2].forEach(tile => {
        const use = tile.querySelector('use');
        use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${tile.dataset.type}`);
    });
}

// 初始化游戏时调用
newGame();

// 以下是保持不变的核心游戏逻辑（areAdjacent、checkMatches、handleMatches）
// 注意：需要将原代码中的数字类型判断改为字符串类型比较
// 例如将 tile.dataset.type === 改为 tile.dataset.type ===
// 并在生成新方块时使用 TYPES 数组

// 示例修改后的检查匹配逻辑：
function checkMatches() {
    const tiles = Array.from(grid.children);
    let matched = new Set();

    // 横向检查
    for (let row = 0; row < ROWS; row++) {
        for (let col = 0; col < COLS - 2; col++) {
            const index = row * COLS + col;
            if (tiles[index].dataset.type === tiles[index+1].dataset.type &&
                tiles[index].dataset.type === tiles[index+2].dataset.type) {
                matched.add(index);
                matched.add(index+1);
                matched.add(index+2);
            }
        }
    }

    // 纵向检查
    for (let col = 0; col < COLS; col++) {
        for (let row = 0; row < ROWS - 2; row++) {
            const index = row * COLS + col;
            if (tiles[index].dataset.type === tiles[index+COLS].dataset.type &&
                tiles[index].dataset.type === tiles[index+2*COLS].dataset.type) {
                matched.add(index);
                matched.add(index+COLS);
                matched.add(index+2*COLS);
            }
        }
    }

    if (matched.size > 0) {
        handleMatches(matched);
        setTimeout(checkMatches, 500);
    }
}

function handleMatches(matched) {
    score += matched.size * 10;
    document.getElementById('score').textContent = `得分: ${score}`;

    matched.forEach(index => {
        const tile = grid.children[index];
        const newType = TYPES[Math.floor(Math.random() * TYPES.length)];
        tile.dataset.type = newType;
        const use = tile.querySelector('use');
        use.setAttributeNS("http://www.w3.org/1999/xlink", "xlink:href", `#${newType}`);
    });
}

// 保持 areAdjacent 函数不变
function areAdjacent(tile1, tile2) {
    const index1 = Array.from(grid.children).indexOf(tile1);
    const index2 = Array.from(grid.children).indexOf(tile2);

    const row1 = Math.floor(index1 / COLS);
    const col1 = index1 % COLS;
    const row2 = Math.floor(index2 / COLS);
    const col2 = index2 % COLS;

    return (Math.abs(row1 - row2) === 1 && col1 === col2) ||
           (Math.abs(col1 - col2) === 1 && row1 === row2);
}
</script>
</body>
</html>